# 数据库笔记

## Chapter1 - Introduction

### Chapter1-1 - History of Database System 

What is a Database System? 

- Database(data, metadata) 
- Hardware (disks)

- Software (DBMS)
- People (users, database designers and database administrators DBA)

### Chapter1-2 - Overview of a Database Management System (DBMS)

The DBMS is expected to:

- Allow users to **create** new database and specify their structure. 
- Give users the ability to **query** the data.

- Support the **storage** of very large amounts of data.

- **Enable durability, recovery** of failures, errors of many kinds.
- **Control access** to data from many users at once.

Function of DBMS:

- **Design** the structure of their information (e.g. relational model)
- **Operate** (query, modify) on the data
- Manage huge amount of data and support efficient, concurrent, secure, atomic access to very large amounts of data

Three components of DBMS:

- Query processor: The query compiler, execution engine
- Transaction manager: Logging, concurrency control, deadlock resolution
- Storage manager: Control the placement of data on disk, and its movement between disk and main memory



Three Users:

- Naïve users – invoke one of the permanent application programs that have been written previously
- Application programmers – interact with system through database manipulation language
- Specialized users – write specialized database applications that do not fit into the traditional data processing framework

Data Administrator(DBA):

- Coordinates all the activities of the database system; the database administrator has a good understanding of the enterprise’s information resources and needs.
- Database administrator's duties include:
  - Schema definition
  - Storage structure and access method definition
  - Schema and physical organization modification
  - Granting user authority to access the database
  - Specifying integrity constraints
  - Acting as liaison with users
  - Monitoring performance and responding to changes in requirements

### Chapter1-3 - Three aspects of database-system studies

- **Modeling and design of databases.** (how is the information structured?)
- **Programming: queries and DB operations like update.** (how does one express queries and other operations on the database)
- **DBMS implementation.** (how to build a DBMS)



## Chapter2 - Relational Model

### Chapter2-1 - The Relational Model of Data

What is a data model?

A **data model** is a notation for describing data or information. It consists of three parts:

- **Structure** of the data: mathematical representation of data
- **Operations** on data. 
- **Constraints**.

Two important data model:

- **The relational model** ( and object-relational model): relational model = tables
- **The semistructured-data model**: semistructured model = trees/graphs XML and its related standards.



**A relation is a Table**

- Each attribute has a **domain,** an element type. 
- Attributes: column headers such as name, manf
- Relation name: Beers

|       name        |      manf      |
| :---------------: | :------------: |
| Winterbrew Pete’s |     Pete’s     |
|     Bud Lite      | Anheuser-busch |

​																												     **Beer**

**Schemas (关系模式)**

- *Relation schema* = relation name and attribute list.
  - Optionally: types of attributes.
  - Example: Beers(name, manf) or Beers(name: string, manf: string)
- *Database* = collection of relations.
- *Database schema* = set of all relation schemas in the database.

**Relation Instances (关系实例)** is current set of rows for a relation schema.

**Underline** = ***key*** (tuples cannot have the same value in all key attributes).



**Database Schemas in SQL**

- **Create a relation**: 

- ```sql
  CREATE TABLE beers (
   name string primary key, 
   manf string)
  ```

- **Delete a relation**

- ```sql
  DROP TABLE beers
  ```

- **Modify schemas**

- ```sql
  ALTER TABLE beers ADD manf_address string;
  ALTER TABLE beers DROP manf;
  ```



**Three kinds of table**

- **Stored relations**: tables, a relation that exists in the database, can be modified or queried. real, stored.
- **Views**: relations defined by a computation. virutal, not really exists.
- **Temporary tables**: constructed by the SQL processor when it performs. thrown away, not stored.



**SQL Values**

- **Integers**
- **Reals**
- **Strings** requires ***single quotes***.
  - Two single quotes = real quote, e.g., ’Joe’’s Bar’.
- **Bit strings** of fixed or varying length, BIT(n) means bit string of length n 
- **Any value** can be **NULL**.
- **Boolean**: true, false, **unknown**
- **Date**: ’yyyy-mm-dd’
- **Time**: ’hh:mm:ss’



**Declaring Keys**

- An attribute or list of attributes may be declared **PRIMARY KEY** or **UNIQUE**. (一个或多个属性)
- Meaning: no two tuples of the relation may agree in all the attribute(s) on the list.
- PRIMARY KEY or UNIQUE attributes can be declared when creating a table.
- **PRIMARY KEY** : only **one** PRIMARY KEY , **No attribute of a PRIMARY KEY can ever be NULL in any tuple.**
- **UNIQUE**: **several** UNIQUE attributes, **may have NULL’s values**.
- **NOT NULL**: every tuple must have a real value for this attribute. i.e. **the value for this attribute may never be NULL.**
- **DEFAULT value** = says that if there is no specific value known for this attribute’s component in some tuple, use the stated <value>.

**Declaring Multiattribute Keys**

```sql
CREATE TABLE Sells (
  bar CHAR(20),
  beer VARCHAR(20), 
  price REAL,
  PRIMARY KEY (bar, beer)
);
```



**Semistructured Data**

**Motivation**:

- flexible representation of data.
- sharing of *documents* among systems and databases.

**Graphs of Semistructured Data**

- **Nodes** = objects.
- Labels on **arcs** (like attribute names).
- Atomic values at **leaf nodes** (nodes with no arcs out).
- **Flexibility**: no restriction on
  - Labels out of a node.
  - Number of successors with a given label.



### Chapter2-2 - Relational Algebra

#### **Chapter2-2-1 - Relational Algebra on Set**s

- **Union**, **intersection**, and **difference**.
  - Usual **set** operations, but ***both operands must have the same relation schema*.**
- **Selection**: picking certain rows.
- **Projection**: picking certain columns.
- **Products** and **joins**: compositions of relations.
- **Renaming** of relations and attributes.



**Selection**
$$
R_1 := \sigma_C(R_2)
$$

- *C* is a condition (as in “if” statements) that refers to attributes of R2.
- R1 is all those tuples of R2 that satisfy *C*.

**Projection**
$$
R_1 := \pi_L(R_2)
$$

- *L* is a list of attributes from the schema of R2.
- R1 is constructed by looking at each tuple of R2, extracting the attributes on list *L*, in the order specified, and creating from those components a tuple for R1.
- Eliminate duplicate tuples, if any.
- **Extended Projection**: we allow the list *L* to contain arbitrary expressions involving attributes:
  - Arithmetic on attributes, e.g., *A*+*B->C*.
  - Duplicate occurrences of the same attribute.

**Products(Cross Join)**
$$
R_3 := R_1 \times R_2
$$

- Pair each tuple t1 of R1 with each tuple t2 of R2.
- Concatenation t1t2 is a tuple of R3. 
- Schema of R3 is the attributes of R1 and then R2, in order.
- If attribute *A* has the same name in R1 and R2: use R1.*A* and R2.*A*.

**Theta Join**
$$
R_3 := R_1 \bowtie_C R_2 \\
R_3 := \sigma_C(R_1 \times R_2)
$$
上下两者等价，即先做乘积，再做选择（不消除重复列）

**Natural Join**
$$
R_3 := R_1 \bowtie R_2
$$

1. Equating attributes of the same name 

2. Projecting out one copy of each pair of equated attributes.

**Renaming**
$$
R_1 := \rho_{R_1(A_1, \dots, A_n)}(R_2)\\
R_1(A_1, \dots, A_n) := R_2 
$$
makes R1 be a relation with attributes A1,...,A*n* and the same tuples as R2.

**Precedence of relational operators:**

1. [σ, π, ρ] (highest). 

2. [Χ, ⋈].

3. ∩.
4. [∪, —]

**Three notations:**

1. Sequences of assignment statements. :=

   写多个表达式，表达式的左边可用临时关系名表示

2. Expressions with several operators. 

   比较长的表达式，通常包含多种关系代数符

3. Expression trees

**Self Join**

- Motivation: 
  - Sometimes, conditions and query results are in the same table.
  - Recursion situation:
    - Parents (Parents, child) in DB
       We want to know grandparents information.
- **Using Sells(bar, beer, price), find the bars that sell *two different* *beers* at the *same* *price*.**
  1. 先对beer进行改名，而另两个属性不变，创建新的表
  2. 让新的表与老的表进行自然连接
  3. 进行比较，筛选掉两个beer相同的重复项，如果为了防止对称情况将不等号改为小于号
  4. 最后再得到对应列

$$
\pi_{bar}(\sigma_{beer < beer_1}(Sells \bowtie \rho_{S(bar, beer_1, price)}(Sells))
$$



#### **Chapter2-2-2 - Relational Algebra on Bags**

A ***bag*** (or ***multiset*** ) is like a set, but an element may appear **more than once**.

Bag can be represented as its elements and occurrences (count).

**Operations on Bags**

- **Selection** applies to each tuple, so its effect on bags is like its effect on sets.

- **Projection** also applies to each tuple, but as a bag operator, we do not eliminate duplicates.

  - 不需要消除重复项使得投影运算在bag上效率高于在set上

- **Products** and joins are done on each pair of tuples, so duplicates in bags have no effect on how we operate.

- **Bag Union**: An element appears in the union of two bags the **sum** of the number of times it appears in each bag.

  - 次数相加

- **Bag Intersection**: An element appears in the intersection of two bags the **minimum** of the number of times it appears in either.

  - 取最小的次数

- **Bag Difference**: An element appears in the difference *A* – *B* of bags as many times as it appears in *A*, **minus** the number of times it appears in *B*.

  - 次数相减，如果A的次数比B小，则记为0，结果中不出现

- ***not all* algebraic laws that hold for sets also hold for bags.**

  

#### **Chapter2-2-3 - Constraints on Relations**

- The ability to restrict the data that may be stored in a database.
- Relational algebra: used as a constraint language abstractly.

**Two ways to express constraints**

R,S: expressions of relational algebra

1. R = 0 : “there are no tuples in the result of R” or the value of R must be empty.

2. R 为 S 子集 : “every tuple in the result of R must be in the result of S”



## **Chapter3 - Design Theory for Relational Database**

### Chapter3-1 - Functional Dependencies

*X* -> *Y* is an **assertion** about **a relation** **R** that whenever two tuples of *R* agree on all the attributes of *X*, then they must also agree on all attributes in set *Y*. （在关系R中，对于每一个元组，如果X属性（集）确定了，那么Y属性（集）也确定，则成X -> Y为关于关系R的一个**断言**）

- Exist in a relational schema as a **constraint**. 
- Agree for **all instances** of the schema. 

**Splitting Right Sides of FD**

- *X* -> *A*1*A*2...*An* holds for *R* exactly when each of *X* -> *A*1, *X* -> *A*2,..., *X* -> *An* hold for *R*. 
  - Example: *A* -> *BC* is equivalent to *A* -> *B* and *A* -> *C*.
- There is no splitting rule for left sides.

**Trivial Functional Dependencies**

如果右侧为左侧的子集，则为平凡函数依赖，否则为非平凡函数依赖

Sells(bar, beer, price)

- bar, beer -> bar (trivial functional dependencies) 
- bar, beer -> price (nontrivial function dependencies)

**Keys of Relations（重要！！！！）**

- *K* is a **<u>*superkey*</u>** for relation *R* if *K* functionally determines all of *R*.
- *K* is a ***<u>key</u>*** for *R* if *K* is a superkey, but no proper subset of *K* is a superkey. (minimality)

（key的范围比superkey窄，只有superkey的子集不能再为superkey时，才能称之为key。无论是key还是superkey都能决定关系R。key一定是superkey）



**Many Inference Rules（用于寻找新的函数依赖）**

- Reflexivity:
   If {B1B2...Bm} 子集于 {A1,A2,...An} then
   A1,A2,...An -> B1B2...Bm called trivial FD’s
- Augmentation:
   IfA1,A2,...An 子集于 B1B2...Bm then,
   A1,A2,...An C1,C2..Ck -> B1B2...Bm C1,C2..Ck
- Transitivity:
   If A1,A2,...An -> B1B2...Bm,and B1B2...Bm -> C1,C2..Ck then, A1,A2,...An -> C1,C2..Ck

**Closure Test（用于寻找新的函数依赖）**

**一个属性集可以决定其闭包内的所有属性**

An easier way to test is to compute the *closure* of *Y*, denoted *Y+*.

- Basis: *Y*+ =*Y*.
- Induction: Look for an FD’s left side *X*  that is a subset of the current *Y+* . If the FD is *X* -> *A*, add *A* to *Y+* . 
- End: when Y+ can not be changed.

推导过程：如果左侧是Y+的子集，则将右侧加入Y+

**Closure and Keys: if the closure of X is all attributes of a relation, then X is a key /superkey.**

定理：如果X的闭包是关系的所有属性，那么X是一个key/superkey



**Basis** **for Functional Dependencies**

如果一个关系给定了其所有的函数依赖，由于函数依赖是可以通过其他的一些函数依赖推导而来（如前面的法则以及闭包算法），我们可以确定一个最小的函数依赖集合来表示一个关系的所有函数依赖

**Basis** for the FD’s of R: a set of FD’s that can infer all the FD’s that hold for R

如果这个Basis不能再减少了称为**Minimal Basis**



### Chapter3-2 - Decomposition

**Relational Schema Design**

Goal of relational schema design is to avoid anomalies and redundancy.

- *Update anomaly* : one occurrence of a fact is changed, but not all occurrences.
- *Deletion anomaly* : valid fact is lost when a tuple is deleted.

Example: **Drinkers(<u>name</u>, addr, <u>beersLiked</u>, manf, favBeer)**

|  name   |    addr    | beersLiked |  manf  |  favBeer  |
| :-----: | :--------: | :--------: | :----: | :-------: |
| Janeway |  Voyager   |    Bud     |  A.B.  | WickedAle |
| Janeway |    ???     | WickedAle  | Pete’s |    ???    |
|  Spock  | Enterprise |    Bud     |  ???   |    Bud    |

数据出现了冗余：表中的???项都可以由上下文推出

数据出现了异常：

- 更新异常：如果Janeway的地址改变了，我们是否会改变其所有元组的addr？
- 删除异常：如果没有人喜欢Bud啤酒，我们会失去其制造商的信息

解决：将Drinkers表分解成更小的表

- Drinker = projection (name, addr, favBeer) (Drinkers) 
- Likes = projection (name, beersLiked) (Drinkers) 
- Beer = projection (beersliked, manf) (Drinkers)



### Chapter3-3 - Normal Forms (BCNF, 3NF)

**Normal Forms: a condition on a relation schema that will eliminate problems**

#### Chapter3-3-1 - BCNF

We say a relation *R* is in ***BCNF*** if whenever *X* -> *Y* is a nontrivial FD that holds in *R*, *X* is a superkey.

**如果关系R遵循BCNF，则对于任何非平凡函数依赖X -> Y，X一定是一个superkey**

Example：

- Drinkers(<u>name</u>, addr, <u>beersLiked</u>, manf, favBeer) 
  - FD’s: name -> addr, favBeer, beersLiked -> manf
  - Only key is {name, beersLiked}.
  - In each FD, the left side is *not* a superkey. 
  - *Drinkers* is not in BCNF

- Beers(<u>name</u>, manf, manfAddr)
  - FD’s: name -> manf, manf -> manfAddr
  - Only key is {name} .
  - name -> manf does not violate BCNF, but manf -> manfAddr does.
  - *Beers* is not in BCNF

**Decomposition into BCNF**

- Given: relation *R* with FD’s *F*.
- Aim: decompose R to reach BCNF
- Step 1: Look among the given FD’s for a BCNF violation *X* -> *Y*.
  - – If any FD following from *F* violates BCNF, then there will surely be an FD in *F* itself that violates BCNF.
- Step 2: Compute X+
  - – Not all attributes, or else X is a superkey
- Step 3: Replace *R* by relations with schemas:
  1. *R*1 = *X*+.
  2. *R*2 =*R* – (*X*+ – *X*).
- Step 4: *Project* given FD’s *F* onto the two new relations.

总结：对于所有违反BCNF的函数依赖，首先计算依赖左侧的闭包，并根据这个闭包将R拆分成两个关系R1和R2，其中关系R1就是X的闭包，关系R2为R减去X的闭包和X的差，并将函数依赖分配给两个关系。直到所有关系的函数依赖都满足BCNF为止。

Example: 

**Drinkers (<u>name</u>, addr, <u>beersLiked</u>, manf, favBeer)**

*F* = name -> addr, name -> favBeer, beersLiked -> manf

显然三个函数依赖都不符合BCNF，分解步骤如下

1. 对于name -> addr，计算name+ = {name, addr, favBeer}
2. 将表分解为
   - Drinkers1(<u>name</u>, addr, favBeer)	        FD(name -> addr, name -> favBeer)
   - Drinkers2(<u>name</u>, <u>beersLiked</u>, manf)     FD(beersLiked -> manf)
3. 表Drinkers1已经满足BCNF，表Drinkers2不满足。计算beersLiked+ = {beersLiked, manf}
4. 将表Drinkers2分解为
   - Drinkers3(<u>beersLiked</u>, manf)	FD(beersLiked -> manf)
   - Drinkers4(<u>name</u>, <u>beersLiked</u>)
5. 至此所有表都满足BCNF，分解完毕



#### Chapter3-3-2 - 3NF

An attribute is ***prime*** if it is a member of any key.

*X* -> *A* violates 3NF **if and only if** *X* is not a superkey, **and** also *A* is not prime.

**如果函数依赖X -> A触犯了3NF，则X不是superkey，且A也不是某一个key的其中一个成员**

显然如果一个关系遵循BCNF，则其所有函数依赖左侧都为superkey，其固然也不会触犯3NF的条件，这个关系一定也遵循3NF

We say a relation *R* is in ***3NF*** if *X* -> *Y* is a nontrivial FD that holds in *R*, *X* is a superkey, **or** Y is a prime （即上一个命题的否命题）

Example:

- **R(A,B,C)** with FD’s *AB* -> *C* and *C* -> *B*, we have keys *AB* and *AC*.
  - Thus *A*, *B*, and *C* are each prime.
  - Although *C* ->*B* violates BCNF, it does not violate 3NF.
  - **R(A,B,C)** above is in 3NF, not in BCNF



**Other Normal Forms**

- **2NF**: no nonkey attribute is dependent on only a portion of the primary key.
  - 没有任何的非码属性依赖于主码的子集（可以依赖于主码）
  - Example: **R(<u>a</u>, b, c, d)** FD’s= a -> b, a -> c, c -> d
    - 由于主码为a，显然满足2NF
    - c -> d违反了3NF，因为c不是superkey，d也不是任何key的member
- **1NF**: every component of every tuple is an atomic value.
  - 关系的每一列都应为原子值，不能是一个元组
  - Example: **R(<u>a, b</u>, c, d)** FD’s ab -> c, a -> d
    - 各个属性均为原子值，显然满足1NF
    - 但是d为非码属性，a为主码ab的子集，违反2NF



**Decomposition into 3NF**

**Properties of a decomposition**

Elimination of anomalies by a decomposition, it needs other two properties:

1. ***Lossless Join***: it should be possible to project the original relations onto the decomposed schema, and then reconstruct the original. （可以讲原来的关系分解，也能将分解的关系重构成原来的关系）
   - BCNF分解和3NF分解都有这个性质
2. ***Dependency Preservation***: it should be possible to check in the projected relations whether all the given FD’s are satisfied. （所有的函数依赖都能够得到保留）
   - BCNF分解没有这个性质，而3NF分解有这个性质。即3NF分解一定能保留所有的函数依赖

**3NF Synthesis Algorithm**

Need ***minimal basis*** for the FD’s:

1. Right sides are single attributes. （右侧属性集只能有一个属性）
2. No FD can be removed. （不能移除任何一个函数依赖）
3. No attribute can be removed from a left side. （左侧的属性不能被移除）

**Constructing a** **Minimal Basis**

1. Split right sides. （将右侧为集合的FD进行拆分）
2. Repeatedly try to remove an FD and see if the remaining FD’s are equivalent to the original. （尝试移除FD）
3. Repeatedly try to remove an attribute from a left side and see if the resulting FD’s are equivalent to the original. （尝试移除FD左侧）

**3NF Synthesis** **–** **method**

1. Find a minimal basis for F
2. One relation for each FD in the minimal basis.
   1. Schema is the union of the left and right sides.
   2. X -> A then (XA) is a schema.
3. If no key is contained in an FD, then add one relation whose schema is some key.

Example: 

- **R(A, B, C, D)**	FD’s *A* -> *B* and *A* -> *C*. Key is AD
  - 关系拥有的两个函数依赖即为其Minimal Basis，分解为(A, B)和(A, C)
  - 由于上两个FD都不包含码，再为码加一个关系(A, D)，分解完成
- **R(A, B, C, D, E)**    FD’s AB -> C, C -> B, A -> D. Key is ABE, ACE
  - 类似，三个函数依赖即为Minimal Basis，分解为(A, B, C), (C, B), (A, D)
  - 由于(C, B)是(A, B , C)的子集，删除(C, B)
  - 由于剩余的两个FD都不包含码，加入任意一个码(A, B, E)或(A, C, E)



### Chapter3-4 - Multivalued Dependencies (and 4NF)

#### Chapter3-4-1 - Multivalued Dependencies

**Definition of MVD**

A *multivalued dependency* (MVD) on *R*, **X** ->-> **Y** , says that if two tuples of *R* agree on all the attributes of *X*, then their components in *Y* may be swapped, and the result will be two tuples that are also in the relation.

理解：对于X集合的任意可能取值，Y集合的在其取值范围内的元组一定在关系R中，这与关系R外的其他属性都是**独立**的！！！

Example: 

**Drinkers(name, addr, phones, beersLiked)**

- name ->-> phones and name ->-> beersLiked.
  - Each of a drinker’s *phones* appears with each of the *beers* they like in **all combinations**.
  - This repetition is unlike FD redundancy.
- name -> addr is the only FD

**MVD Rules**

- **Every FD is an MVD**
  - 显然对于某个依赖X -> Y，对于给定的X，Y值固定也没有可以交换的空间，因此函数依赖必然多值依赖。
- **Complementation**
  - If *X* ->-> *Y*, and *Z* is all the other attributes, then *X* ->-> *Z*.
  - 如果 X ->-> Y，对于给定的X，则Y与其他的所有属性Z必然是独立的，相反地，Z与其他所有属性是独立的，故也有X ->-> Z
- **INTERSECTION RULE**
  - X ->-> Y, X ->-> Z, THEN X ->-> Y INTERSECTION Z
- **TRANSITIVE RULE**
  - X ->-> Y, Y ->-> Z, THEN X ->-> Z - Y
- Like FD’s, we cannot generally split the left side of an MVD.
- Unlike FD’s, we cannot split the right side either. （多值依赖的左右项都**不**能直接分割）



#### Chapter3-4-2 - 4NF

The redundancy that comes from MVD’s is not removable by putting the database schema in BCNF.

***Nontrivial MVD*** means that:

1. *Y* is not a subset of *X*, and
2. *X* and *Y* are not, together, all the attributes.

**非平凡MVD：右侧不能是左侧的子集，且X和Y的并集不能是包含所有属性的属性集**

A relation *R* is in ***4NF*** if: whenever *X* ->-> *Y* is a nontrivial MVD, then *X* is a superkey.

**如果R满足4NF，那么对应任意的非平凡多值依赖X ->-> Y，X一定是superkey**

Note that the definition of “superkey” still depends on **FD’s** only.

**如果一个关系R满足4NF，其一定满足BCNF**

- 对于关系R，如果某个非平凡函数依赖X -> Y不符合BCNF，即X不是superkey
- 显然X ->-> Y为非平凡的多值依赖，故也不符合4NF



**Decomposition and 4NF**

- Input: relation R + FDs for R + MVDs for R 
- Output: decomposition of R into 4NF relations with “lossless join”
- Compute keys for R
- Repeat until all relations are in 4NF:
  1. Pick any R’ with nontrivial A ->-> B that violates 4NF
  2. Decompose R’ into R1(A, B) and R2(A, rest) 
  3. Compute FDs and MVDs for R1 and R2 
  4. Compute keys for R1 and R2

即对于违反4NF的非平凡多值依赖，将原表拆成两部分：第一个表包含多值依赖的左右两边，第二个表包含多值依赖的左边和多值依赖外的属性。

Example:

**Drinkers(<u>name</u>, addr, <u>phones</u>, <u>beersLiked</u>)**

- FD: name -> addr 
- MVD’s: name ->-> phone, name ->-> beersLiked
- Key is {name, phones, beersLiked}. 
- All dependencies violate 4NF.
  - 首先对于FD name -> addr，将表拆分为
    - Drinkers1(<u>name</u>, addr)	FD: name -> addr
    - Drinkers2(<u>name, phones, beersLiked</u>). MVD: name ->-> phones, name ->-> beersLiked
  - Drinkers1已经满足4NF，Drinkers2还没有，对于name ->-> phones，将表拆分为：
    - Drinkers3(<u>name, phones</u>).   MVD: name ->-> phones
    - Drinkers4(<u>name, beersLiked</u>).   MVD: name ->-> beersLiked
  - 由于新生成的两表内已经不存在非平凡的多值依赖而只有平凡的多值依赖，故都满足4NF，拆分完毕。



**Problem: given a set of MVD’s and/or FD’s that hold for a relation *R*, does a certain FD or MVD also hold in *R* ?**

对于关系R内给定的MVD和FD集合，能否对新的MVD或FD进行推断？

**Solution**: Use **a tableau** to explore all inferences from the given set, to see if you can prove the target dependency.

- To test A -> B? Assume (a,b1) (a,b2) to prove b1=b2
- To apply a FD, equate symbols, as before. 
- To test A ->-> B? Assume (a,b1, rest1) (a,b2,rest2) to prove (a, b2 rest1) in R.
- To apply an MVD, generate one or both of the tuples we know must also be in the relation represented by the tableau.

**Rules for Inferring MVD's + FD's**

Start with a tableau of two rows.

- –  These rows agree on the attributes of the left side of the dependency to be inferred.

- –  they disagree on all other attributes.

- –  Use unsubscripted variables where they agree, subscripts where they disagree.

- Apply a FD X -> Y by finding rows that agree on all attributes of *X*. Force the rows to agree on all attributes of *Y*.

- Apply a MVD X ->-> Y by finding two rows that agree in *X*.

  – Add to the tableau one or both rows that are formed by swapping the *Y*-components of these two rows.

- To test whether U -> V holds, we succeed by inferring that the two variables in each column of V are actually the same.

- If we are testing U ->-> V, we succeed if we infer in the tableau a row that is the original two rows with the components of V swapped.

例子请参见ppt！



**Relationships Among Normal Forms**

|             Property              |  3NF  | BCNF  |  4NF  |
| :-------------------------------: | :---: | :---: | :---: |
| Eliminates redundancy due to FDs  | Most  |  Yes  |  Yes  |
| Eliminates redundancy due to MVDs |  No   |  No   |  Yes  |
|           Preserves FDs           |  Yes  | Maybe | Maybe |
|           Preserves MVD           | Maybe | Maybe | Maybe |
|    Equal to original relation     |  Yes  |  Yes  |  Yes  |



## Chapter4 - High-Level Database Models

### Chapter4-1 - ER Model

#### Chapter4-1-1 - ER Diagram

**Purpose of E/R Model**

- Sketch database schema designs
  - Includes some constraints, but not operations. 
- Designs are pictures called entity-relationship diagrams.
- Convert E/R designs to relational DB designs.

**Representing “Multiplicity”**

- Show a many-one relationship by an **arrow** entering the “**one**” side.
- Show a one-one relationship by arrows entering **both** entity sets.
- **Rounded arrow** = “exactly one,” i.e., each entity of the first set is related to exactly one entity of the target set.
- 一对一的普通箭头意味着两端只能一对一，但也可能一端的某个元素在另一端找不到对应项。如果是rounded arrow，必须恰好都是一对一，而不能出现无对应项的情况。

**Roles**

- an E.S.participates more than once in a relationship.
- Label edges with roles to distinguish.
- 即在一个实体集可能多次参与于一个联系之中，如果出现这种情况，要在边上表明一个字符串（roles）进行区分

**Subclasses**

- Subclass = special case = fewer entities = more properties
- Example: Graduate students are a kind of students with a supervisor.
- **key** at root is key for all.
- **Isa triangles** indicate the subclass relation.

The subclasses of a class can be:

-  ***Complete*** (every object is in at least one subclass) or *partial*.
-  ***Disjoint*** (object in at most one subclass) or *overlapping*.



**Weak Entity Sets（弱实体集）**

**Weak Entity Sets** is an E.S. whose key comes not (completely) from its own attributes, but from the keys of one or more E.S’s to which E is linked by a supporting many-one relationship.

**弱实体集的码并不（完全）来源于它自己的属性，而可能（部分）来源于与其通过多对一的联系相连的一或多个实体集**

- **Many-one-ness** of supporting relationship (includes 1-1) essential.
- **“Exactly one”** also essential, or else we might not be able to extract key attributes by following the supporting relationship.
- **Double diamond** for supporting many-one relationship. 
- **Double rectangle** for the weak entity set.



**Design Techniques**

1. Avoid redundancy.

   - *Redundancy* = saying the same thing in two (or more) different ways.

   - Wastes space and (more importantly) encourages inconsistency.

   - Make an entity set only if it either:

     1. Is more than a name of something; i.e., it has nonkey attributes or relationships with a number of different entity sets （拥有非码属性或和其他不同的实体集有联系）

     2. Is the “many” in a many-one relationship. （在多对一联系中处于多的一端）

2. Limit the use of weak entity sets.

   - Create unique ID’s to compensate: Product-ID, Player-ID，etc.

   - Weak E.S.’s are necessary when:

     1. Such ID’s are not easily created; e.g., “species ID” as part of the standard nomenclature. （标识的ID不容易创建）

     2. No global authority to create them, e.g., crews and studios （没有权限进行创建）

3. Don’t use an entity set when an attribute will do.



**Constraints in the E/R Model**

- **Key constraints**
  - No two entities may agree in their values for all of the attributes that constitute a key. （不同的元组不能有相同的key）
- **Single-value constraints**
  - Each attribute of an entity set has a single value. (not null) （对于实体集的每个属性都只有一个非空的值）
  - A relationship R that is many-one from entity set E to entity set F implies a single-value constraint. (at most one, or exactly one) 
- **Referential integrity constraints** 
  - A value appearing in one context also appears in another, related context. （出现在一个实体集的值也出现在另一个相关的实体集之中）
- Other constraints
  - **Domain constraints** restrict the value of an attribute to be in a limited set. （限制某属性的定义域）
  - **General constrains**, such as placing a constraint on the degree of a relationship, number constraints and so on.

Constraints are part of the model.



#### Chapter4-1-2 - From E/R Diagrams to Relations

**From E/R Diagrams to Relations**

- Entity set -> relation.
  - Attributes -> attributes.
- Relationships -> relations whose attributes are only: 
  - The keys of the connected entity sets.
  - Attributes of the relationship itself.

**Combining Relations**

Combine into one relation for:

1. The relation for an entity-set *E*

2. The relations for many-one relationships of which *E* is the “many.”

Combining Many-Many Relationships would be a mistake. It leads to redundancy

**Handling Weak Entity Sets**

- **Weak entity set**: include attributes for its complete key (including those belonging to other entity sets), as well as its own, nonkey attributes.
- **A supporting relationship**: redundant and yields no relation (unless *it* has attributes).

将弱实体集转化为关系：关系的属性包含弱实体集的码（实体集内以及实体集外）和弱实体集内的非码属性

弱实体集码相关的联系不需要将其转化为关系

**Subclasses: Three Approaches**

1. *Object-oriented* : One relation **per subset of** subclasses, with all relevant attributes.

2. *Use nulls* : One relation; entities have NULL in attributes that don’t belong to them.

3. *E/R style* : One relation for **each subclass**: 

   - Key attribute(s).

   - Attributes of that subclass.



### Chapter4-2 - Object Definition Language (ODL)

**Object-Oriented DBMS’s**

- Standards group: ODMG = Object Data Management Group.
- ODL = Object **Definition** Language, like CREATE TABLE part of SQL.
  - ODL is used to define ***persistent*** classes, whose objects are stored **permanently** in the database.
- OQL = Object **Query** Language, tries to imitate SQL in an OO framework.

**ODL Overview**

A class declaration includes: 

1. A **name** for the class.

2. Optional **key** declaration(s).

3. **Element declarations**. An *element* is either an attribute, a relationship, or a method.

```
// class definition
class <name> {
	<list of element declarations,
	separated by semicolons> 
}

// attribute declaration
// Attributes are (usually) elements with a type that does not involve classes.
attribute <type> <name>;

// relationship declaration
// Relationships connect an object to one or more other objects of one class.
relationship <type> <name> inverse <relationship>;
```

**Inverse Relationships**

- Suppose class *C* has a relationship *R* to class *D*.
- Then class *D* must have some relationship *S* to class *C*.
- *R* and *S* must be **true inverses**.
  - If object *d* is related to object *c* by *R*, then *c* must be related to *d* by *S*.

Example:

```

// The :: operator connects a name on the right to the context containing that name, on the left.
// 使用Set是因为为多对多的关系，如果是一对多的关系，多的那个类内声明另一个一的那个类时不用加Set，参见下面的Multiplicity of 
// Relationship
class GraduateStu { 
	attribute string SID; 
	attribute string addr;
	relationship Set<Project> work_in inverse Project::workforce;
}
class Project {
	attribute Integer pid; attribute string sponsor;
	relationship Set<GraduateStu> workforce inverse GraduateStu::work_in;
	relationship Professor principleProf inverse Professor::management
}
```

**The type of a relationship** is either

1. A class: the object is connected to an object of the class.

2. Set<class name>: the object is connected to a set of objects of the class. 
3. Bag<class name>, List<class name>, Array<class name>: the object is connected to a bag, list, or array of the class object.

**Multiplicity of Relationships** 

- All ODL relationships are **binary**.
- ***Many-many relationships*** have Set<...> for the type of the relationship and its inverse.
- ***Many-one relationships*** have Set<...> in the relationship of the “one” and just the class for the relationship of the “many.”
- ***One-one relationships*** have classes as the type in both directions.

**Structs and Enums**

Details are **types and field names** for a Struct, **a list of constants** for an Enum.

```
// Declaration
attribute [Struct or Enum] <name of struct or enum> { <details> } <name of attribute>;

// Example
class Students { 
		attribute string name;
		attribute Struct Addr {
				string street, 
				string city, 
				int zip
    } address; 
    attribute Enum Stu_type { 
    		FULL, 
    		part-time, 
    		auditor 
    } type; 
    relationship ...
}
```

**ODL Subclasses**

Subclass lists only the properties **unique** to it. It also inherits its superclass’ properties.

```
// Example
class GraStudent:Students { 
		attribute string superviser;
}
```

**ODL Keys**

```
// Declaration:
// After the class name, add:
(key <list of keys>)

// A key consisting of more than one attribute needs additional parentheses around those attributes.
// Example
class Students (key SID) { ... }

class Course (key (dept,number),(room, hours)){ ... }
```



### Chapter4-3 - Unified Modeling Language (UML)

**Motivation**

- UML is designed to model software, but has been adapted as a database modeling language.
- Midway between E/R and ODL.
  - No multiway relationships as in E/R.
  - But allows attributes on binary relationships, which ODL doesn’t.
  - Has a graphical notation, unlike ODL.

**Classes**

- Sets of objects, with **attributes** (*state* ) and **methods** (*behavior* ).
- Attributes have types.
- PK indicates an attribute in the primary key (optional) of the object.
- Methods have declarations: *arguments* (if any) and *return type*.

|                           Students                           |
| :----------------------------------------------------------: |
|                 PK Name: string Addr: string                 |
| setName(n) setAddr(a) getName() : string getAddr() : string Gender() : boolean |

为主码的属性前加PK，冒号后为类型（和swift语法很像）。对于方法，括号内写参数，方法后为返回的类型。

**Associations**

- **Binary** relationships between classes.
- Represented by **named lines** (no diamonds as in E/R). （连线即可，不需要箭头）
- Multiplicity at each end.
  - *m* .. *n* means between *m* and *n* of these associate with one on the other end.
  - \* = “infinity”; e.g. 1..* means “at least one.”
- 即，先连线，中间写联系的名字，两边写Multiplicity

**Association Classes**

- Attributes on associations are permitted.
- Called an *association class*.
- Analogous to attributes on relationships in E/R.

即在联系的连线下再加一个方框，写着联系类名及其属性（不能有方法）

**Self-Association**

An association can have both ends at the same class.

即联系的两端为同一个类。此时联系的任意一端要标一个箭头，联系的名字应当有两个以区分两端

**Subclasses**

- In a typical object-oriented system, subclasses are disjoint.
- E/R model allows overlapping subclasses.
- E/R model and object-oriented system allow either **complete** or **partial** subclasses. There is no requirement that a member of the superclass be in any of subclass. 

格式：子类与父类间有一个空心三角箭头，箭头端指向父类。

**Two special many-one relationships**

Relationships with implication that the objects on one side are “owned by” or are “part of objects” on the other side.

- **Aggregations**: represented by a diamond at the end of the connecting line, at the “owner” side
- **Compositions**: represented by **solid diamond** at owner side.
- 区别：Composition has a strong part-whole relationship, the part and the whole have the same life cycle.

格式：聚合为空心菱形，组合为实心菱形，菱形端为whole端，并标记1，另一段标记\*



## **Chapter5 - Algebraic and Logical Query Language**

**Extended (“Nonclassical”) Relational Algebra**

Add features needed for SQL bags.

1. Duplicate-elimination operator \delta
2. Extended projection.
3. Sorting operator \tau
4. Grouping-and-aggregation operator \gamma
5. Outerjoin operator \bowtie^。

**Duplicate Elimination**
$$
\delta(R)
$$
Generate relation with one copy of each tuple that appears one or more times in R.

**Extended Projection**

在关系代数时已经讲过，这里不赘述

**Sorting**
$$
\tau_L(R)
$$
Generate list of tuples of R, ordered according to attributes on list L

Note that result type is outside the normal types (set or bag) for relational algebra. Consequence, \tau cannot be followed by other relational operators.

**Sorting的结果是生成一个List，List的元素为R中的各个元组按照L排序，Sorting没有生成新的关系，不能与别的操作符共同使用！！**

**Aggregation Operators**

- Aggregation operators apply to entire columns of a table and produce a **single result.**
- The most important examples: **SUM**, **AVG**, **COUNT**, **MIN**, and **MAX**.

**Grouping Operator**
$$
\gamma_L(R)
$$
where L is a list of elements that are either

1. Individual (grouping) attributes or
2. Of the form \theta(A), where \theta is an aggregation operator and A the attribute to which it is applied, computed by:

- Grouping R according to all the grouping attributes on list L.
- Within each group, compute \theta(A), for each element \theta(A) on list L
- Result is the relation whose column consist of one tuple for each group. The components of that tuple are the values associated with each element of L for that group.

L内的属性只能为两种类型：一种是被分组的属性，另一种是被聚合操作符包裹的属性。先分组再聚合组成新的关系

**Outerjoin**
$$
R_3 = R_1 \bowtie^。R_2
$$
外连接用来解决自然连接信息丢失的问题。对于无法匹配元素，仍然将其加到结果之中，但是另一个表中的属性都置为空值。

左外连接在蝴蝶结符号下标一个L，右外连接下标R。左外连接保证左表信息不丢失，右外连接保证右表信息不丢失。



**Predicates and Atoms**

- A **predicate** followed by its arguments is called an **atom**.
  - **Atom = *predicate* and arguments.**

  - **Predicate = relation name or arithmetic predicate,**

    *e.g*. <.

  - Arguments are variables or constants.

- Relations are represented in **Datalog** by predicates.

- R(a1, a2, ... an) has value TRUE if (a1,a2,...an) is a tuple of R, otherwise, it is FALSE.

Example (**Anatomy of a Rule**):

​	**Frequents(drinker, bar)   Likes(drinker, beer)    Sells(bar, beer, price)**

​	Define a rule called “happy drinkers” --- those that *frequent* a bar that *serves* a beer that they *like*.

​	Happy(d) <- Frequents(d, bar) AND Likes(d, beer) AND Sells(bar, beer, p)

​	左侧为得出的结果subgoal，箭头表示if，右侧为AND连接的subgoals（atom也是subgoal的一种，包含关系名及其参数）

​	关系名第一个字母大写，参数第一个字母小写

**Applying a Rule**

- Approach 1: consider all combinations of **values of the variables**.（遍历各个变量所有可能的组合）
  - If all subgoals are true, then evaluate the head.
  - The resulting head is a tuple in the result.
- Approach 2: For each subgoal, consider **all tuples** that make the subgoal true.（说实话我不知道这两个有啥区别，遍历一遍就完事了）
  - If a selection of tuples define a single value for each variable, then add the head to the result.

**Arithmetic Subgoals**

subgoal也可以是算术运算，如将某个变量与常数进行比较

**Negated Subgoals**

在subgoal前加上NOT关键字进行否运算

**Safe Rules**

- A rule is *safe* if:
  1. Each variable in head,
  2. Each variable in an arithmetic subgoal, and
  3. Each variable in a negated subgoal,

  also appears in a nonnegated, relational subgoal.

-  Safe rules prevent infinite results.

Example: Unsafe Rules

1. S(x) <- R(y) （违反1）
2. S(x) <- R(y) AND NOT R(x) （违反1，3）
3. S(x) <- R(y) AND x < y （违反1，2）



**Datalog Programs**

- ***Datalog program* = collection of rules**.
- In a program, predicates can be either
  1. EDB = *Extensional Database* = stored table.
  2. IDB = *Intensional Database* = relation defined by rules.
- Never both! No EDB in heads.
- 即EDB为存储在硬盘中的表，IDB为通过刚刚的规则推导出来的表
- 如果一个IDB可能由多个rules组成（有些rule生成中间结果作为后面的rule的参数）

Datalog的规则也可以应用在Bag模型上，道理类似。

**From Relational Algebra to Datalog**
$$
R \cap S: I(x) \leftarrow R(x) AND S(x) \\
R \cup S: I(x) \leftarrow R(x), I(x) \leftarrow S(x) \\
R - S: I(x) \leftarrow R(x) AND NOT S(x) \\
\pi_A(R): I(A) \leftarrow R(A, B) \\
\sigma_F(R): I(x) \leftarrow R(x) AND F \\
R \times S: I(x, y) \leftarrow R(x) AND S(y) \\
R \bowtie S: I(x, y, z) \leftarrow R(x, y) AND S(y, z)
$$


## **Chapter6 - The Database Language SQL**

第六章特别特别重要，我怕我太早复习然后忘了，所以最后再来更新这一章



## Chapter7 - Constraints and Triggers

Constraints and Triggers

- **A** **constraint** **is** **a relationship among data elements** **that the DBMS is required to enforce.**

  – **Example: key constraints.**

- **Triggers** **are only executed when a specified condition occurs, e.g., insertion of a tuple.**

  – **Easier to implement than many constraints.**

### Chapter7-1 - Constraints

**Types** of Constraints

1. **Non-null, unique** 

   - 即某个属性非空/不能有重复（可能为空）

2. **Key**

   - 作为码的属性既不能为空，也不能重复
   - 表中可以有多个非空、不重复的限制，而只可以有一个码限制

3. **Referential integrity (Foreign-keys)**

   - **Foreign Keys**

     - In relation R a clause that “attribute A references S(B)” says that whatever non-null values appear in the A column of R must also appear in the B column of relation S. B must be declared the primary key for S.
     - 如果关系R的属性A引用了S(B)，即只要在A里出现的**非空值**一定要哦在S的B里面出现，并且B一定是S的**主码**

   - Expressing Foreign Keys

     - Use the keyword **REFERENCES**, either:

       1. **Within the declaration of an attribute, when only one attribute is involved.**

       2. **As an element of the schema**, as:

          **FOREIGN KEY ( <list of attributes> )**

          **REFERENCES <relation> ( <attributes> )**

     - **Referenced attributes must be declared PRIMARY KEY or UNIQUE**.

     - 如果只在一个属性上声明，可以在属性后加上REFERENCES Table(attribute)

     - 如果是一个属性或多个属性，则将外码作为关系的一个元素进行声明（类似主码）

     - 被引用的属性必须是主码或无重复

   - What happens when a foreign key Constraint is violated?

     - 情况一：插入了被引用表中属性不存在的值
       - 插入一定会被拒绝
     - 情况二：删除或更新被引用表中一个被另一个表引用的值
       - 默认情况下删除操作被拒绝
       - 串联（Cascade）情况下，引用的表也会做对应的改变（如把引用的全部元组删除，或更新操作下更新）
       - 删除可能完成，将引用表的对应项置空（之后可能再用update语句进行更新）
       - 以上三种可能按以下语法决定：
         - Add **ON [DELETE, UPDATE] [CASCADE, SET NULL]** to declaration of foreign key.
         - 加在FOREIGN语句后、可以对删除、更新都分别加一个；啥也不加就是默认拒绝

4. **Attribute-based Check**

   - 在属性声明的后面加上**CHECK(condition)**
     - condition内可能会包含被检查的属性
     - condition内可能在子查询中包含其他的属性或关系
     - 当与condition相关的属性、表改变了，check都会被触发（如insert，update；delete不会触发！！！）
   - **Effect when a value for** **that attribute** **is** **inserted** **or** **updated**.
     - –  **Example: CHECK (price <= 5.00) checks every new price and rejects it if it is more than $5.**
     - –  **Example: CHECK (beer IN (SELECT name FROM Beers))** **not checked if a beer is deleted from Beers** **(unlike foreign-keys).**

5. **Tuple-based Check**

   - 在关系中作为一个独立的元素进行出现，语法和上一个完全一样
     - condition中可以包含当前关系中的任意属性
     - condition中也可以在子查询中出现其他关系或其他关系的属性
     - 跟上面类似，当当前tuple被insert或update时才会触发

6. **General assertions = global constraints**

   - 在SQL的断言（assertion）中，只要与检查内容有关的关系、属性变化了，一定会进行检查
     - **语法：CREATE ASSERTION <name> CHECK (< condition>);**
     - 其定义在schema里，为schema的一个元素
     - 对于上面两种，如果出现了subquery可能会不进行检查而导致条件不满足，而这种断言不会

**Modification** of Constraints

- **Name** **your Constraints**
  - **Example：**
  - **1) Gender Char(1) CONSTRAINT NoAndroCHECK (gender in (‘F’, ’M’)),**
  - **2) Name Char(30) CONSTRAINT NameIsKey PRIMARY KEY,**
- **Altering Constraints on Tables**
  - **Examples:**
  - **1) ALTER TABLE Student DROP CONSTRAINT NoAndro;**
  - **2) ALTER TABLE Student ADD CONSTRAINT NameIskey PRIMARY KEY(name);**

更多的例子请参见ppt



### Chapter7-2 - Triggers

**Motivation**

- **Attribute- and tuple-based checks have** **limited capabilities**
- **Assertions are sufficiently general for most constraint applications, but they are** **hard to implement efficiently.**

Triggers often called event-condition-action rules

- **Event** = a class of changes in the DB, e.g.: insert, delete
- **Condition **= a test as in a where-clause for whether or not the trigger applies.
- **Action** =one or more SQL statements

Example:

```sql
CREATE TRIGGER BeerTrig
	AFTER INSERT ON Sells 						// event
	REFERENCING NEW ROW AS NewTuple 
	FOR EACH ROW
	WHEN (NewTuple.beer NOT IN				// condition
		(SELECT name FROM Beers)) 
	INSERT INTO Beers(name)						// action
    VALUES(NewTuple.beer);
```

- 如果当前触发器的名字存在可以用REPLACE关键词代替CREATE对触发器进行修改
- Event: 
  - AFTER说明在操作完成后触发
  - BEFORE说明在操作完成前触发
  - 如果后面的关系为一个视图的话使用INSTEAD OF（参见下一章）
  - 除了INSERT也可以为DELETE、UPDATE
- Options:
  - FOR EACH ROW：为行级别触发器，如果不声明FOR EACH ROW则为语句级别。当某个元组被修改了，行级别触发器就会被触发；当某条语句执行了（可能会改变多个元组），语句级别触发器执行一次。
  - REFERENCING (NEW OLD) (ROW TABLE) AS name：当event为INSERT时，使用NEW指代新插入的元组（集）；当event为DELETE时，使用OLD指代被删除的元组（集），当event为UPDATE时，使用两者。
- Condition:
  - condition应当返回布尔值
  - 检查时间由event定义的BEFORE或AFTER决定
- Action
  - action内可能包含多条sql语句，使用BEGIN...END将这些语句包裹起来
  - 不要在action内进行查询，应当进行修改

**Event vs. Triggers**

- **Event** **will come** → **wake** **the** **trigger**
- **Steps for** **After** **trigger:**
  - **Event happens**→**test the condition: if true do action otherwise nothing.**
- **Steps for** **before** **trigger:**
  * **Test the condition: if true do action otherwise** **nothing**→**event happens**
- **Steps for** **instead of**:
  - **Test the condition: if true do action otherwise nothing**

触发器可以在action中进行自我触发

ppt中有很多例子，参见ppt，这里不赘述。



## Chapter8 - Views and Indexes

### Chapter8-1 - Views

A ***view*** is a relation defined in terms of stored tables (called *base tables* ) and other views. Two kinds:

1. ***Virtual*** = not stored in the database; just a query for constructing the relation.

2. ***Materialized*** = actually constructed and stored.

```sql
// 默认为virtual
CREATE [MATERIALIZED] VIEW <name> AS <query>;
DROP VIEW <name>

// 查询视图和查询普通表完全一样，参见第六章
```

What Happens When a View Is Used?

- The DBMS starts by interpreting the query as if the view were a base table.

  – Typical DBMS turns the query → relational algebra.

- The queries defining any views used by the query are also replaced by their algebraic equivalents, and “spliced into” the expression tree for the query.

DMBS Optimization

- The typical DBMS will then “optimize” the query by transforming the algebraic expression to one that can be executed faster.
- Key optimizations:
  1. Push selections down the tree.
  2. Eliminate unnecessary projections.

**Modifying Views by Triggers**

-  Generally, it is impossible to modify a virtual view, because it doesn’t exist.
-  **INSTEAD OF trigger** lets us interpret view modifications in a way that makes sense.

Example:

```sql
CREATE VIEW Synergy AS
	SELECT Likes.drinker, Likes.beer, Sells.bar
		FROM Likes, Sells, Frequents
		WHERE Likes.drinker = Frequents.drinker
			AND Likes.beer = Sells.beer AND Sells.bar = Frequents.bar;

// 当你想要向视图插入元组时，触发器被触发，实际上视图内并未执行插入操作，而是在action里对其引用的三个表进行了插入，当然那三个表中的
// 一些值会被置为空值
CREATE TRIGGER ViewTrig
	INSTEAD OF INSERT ON Synergy 
	REFERENCING NEW ROW AS n FOR EACH ROW
BEGIN
  INSERT INTO LIKES VALUES(n.drinker, n.beer); 
  INSERT INTO SELLS(bar, beer) VALUES(n.bar, n.beer); 
  INSERT INTO FREQUENTS VALUES(n.drinker, n.bar);
END;
```



**Materialized Views** 

Stored like a base table.

- **Disadvantage**: each time a base table changes, the materialized view may change.
- **Advantage**: speed up those queries which involve a join of many relations.

当这种视图引用的表改变时，视图也一定要形成相对应的改变（当然不用改变整个视图，将对应变化的元组进行改变即可）

由于这种表被物理存储，进行查询时与查询物理表无异，效率比虚拟视图更高



### Chapter8-2 - Indexes

***Index*** = data structure used to speed access to tuples of a relation, given values of one or more attributes.

```sql
CREATE INDEX BeerInd ON Beers(manf); 
CREATE INDEX SellInd ON Sells(bar, beer);
```

Given a value *v*, the index takes us to only those tuples that have *v* in the attribute(s) of the index.

**Database Tuning**

- A major problem in making a database run fast is deciding which indexes to create.
- Pro: An index speeds up queries that can use it.
- Con: An index slows down all modifications on its relation because the index must be modified too.

**Some useful suggestions**

- Index on its key.

- Index on the following two cases:

  1. If the attribute is almost a key

  2. If the tuples are clustered on that attribute.

     To decrease the cost of accessing data

- If we are doing mostly insertion, very few queries, then we do not want an index



## Chapter9 - SQL Environment

**不考**



## Chapter10 - Advanced Topics in Relational Databases

### Chapter10-1 - Security and User Authorization in SQL

**Aim**:

- Make sure users only see the data they’re suppose to
- Guard the database against updates by malicious users

How SQL control it? 

- Authorization ID 
  - Authorization ID, typically their **name**.
  - Authorization ID may be granted some **particular privileges** on objects.
  - **PUBLIC**: a special built-in authorization ID
    - Granting a privilege to PUBLIC makes it available to any authorization ID.
    - 为PUBLIC授权相当于为每个authorization ID授权
- Privileges
  - File systems identify certain access privileges on files, e.g., read,write,execute.
  - SQL identifies nine types of privileges: 
    - **SELECT** = the right to query the relation
    - **INSERT** = the right to insert tuples into the relation, **may refer to one attribute**, in which case the privilege is to specify only one column of the inserted tuple.
    - **DELETE** = the right to delete tuples from the relation.
    - **UPDATE** = the right to update tuples of the relation, **may refer to one attribute.**
    - **References** = the right to refer to that relation in an integrity constrain.
    - **Usage** = the right to use that element in one’s own declarations.
    - **Trigger** = the right to define triggers on that relations
    - **Execute** = the right to execute a piece of code, such as a PSM procedure or function.
    - **Under** = the right to create subtypes of a given type.

**Obtaining Privileges**

How to grant privilege? 

- **Owner**
  - Owner has all privileges and may GRANT them to **others**
  - **Schema owner**: who create the schema and owns all tables, and other schema elements.
  - **Session owner**: who issued a Connect statement.
  - **Module owner**: who create a module.
- **Granted User**

Example:

```sql
// 1) Sally can query Sells and can change prices, but cannot pass on this power:
GRANT SELECT ON Sells, UPDATE (price) ON Sells TO sally;

// 2) Sally can also pass these privileges to whom she chooses;
GRANT SELECT ON Sells, UPDATE (price) ON Sells TO sally WITH GRANT OPTION;

// 即如果你是拥有者或者被别人调用了以上语句并附带WITH GRANT OPTION选项，你也可以将权限分配给别人
// 否则不能
```

**Checking**

- **Authorization-Checking**

  - Each module, schema, and session has an associated authorization ID.
  - A user’s privileges derive from the current auth. ID that is either
    - module auth. ID if there is one, or 
    - session auth. ID if not.

  Execute the SQL operation only if the current auth. ID possesses all the privileges.

- **Privilege-Checking**

  - The current authorization ID is:
    - the owner of the data, or
    - has been granted by the owner or been granted to user PUBLIC.

  → Executing a module.

**Grant Diagrams**

SQL system maintains a diagram → to keep track of both **privileges** and **their origins**.

- **Nodes** of a grant diagram: a **user** and a **privilege**.
- Privileges with and without the grant option must be represented by two different nodes.
- 两个星号\*\*代表该节点为owner
- 一个星号\*代表该节点拥有GRANT OPTION
- 图参见ppt

**Revoking Privileges**

```sql
REVOKE privileges ON relation FROM users [CASCADE | RESTRICT]
// CASCADE: transitively revoking. 
// 串联：将该用户及其授权后的各个子节点回收权限
// RESTRICT: Revoke not allowed if it would cause any node unreachable from an owner. 
// 限制：如果回收该用户权限会导致某个节点从拥有人是不可达的，则回收失败

// 也可以对GRANT OPTION进行回收，但不回收该用户的权限
REVOKE GRANT OPTION FOR privilege ON relation FROM users [CASCADE | RESTRICT]
```



### Chapter10-2 - Recursive SQL

**不考**



### Chapter10-3 - Object-Relational Model

- Include object orientation and constructs to deal with added data types.
- Allow attributes of tuples to have complex types, including non-atomic values such as nested relations.
- **Preserve relational foundations**, in particular the declarative access to data, while extending modeling power.
- **Upward compatibility** with existing relational languages.



#### Chapter10-3-1 - User-Defined Types in SQL

A user-defined type, or **UDT**, is essentially a class definition, with a structure and methods.

Two uses:

1. As the type of a relation (Rowtypes). 
2. As the type of an attribute of a relation.

Example:

```sql
// UDT Definition
CREATE TYPE <typename> AS (<list of attribute-type pairs>);

CREATE TYPE BarType AS ( 
  name CHAR(20),
	addr CHAR(20)
);

CREATE TYPE BeerType AS (
  name CHAR(20),
	manf CHAR(20) 
);

// Method Declarations in UDTs
CREATE TYPE BarType AS (
  name   CHAR(20),
  addr   CHAR(20))
	METHOD Telnumber() returns CHAR(10); 

CREATE METHOD Telnumber() returns
  CHAR(10)
  FOR BarType
  Begin ... End; // method body
```

**References**

- If T is a type, then REF T is the type of a reference to T, that is, a pointer to an object of type T.
- Often called an “object ID” in OO systems. 
- Unlike object ID’s, a REF is visible.
- 即相当于是指针

```sql
// 这个例子中定义了两个自定义类型的属性，使用REF关键字数据库中存储的是指针，指向对象所在的空间中
CREATE TYPE MenuType AS ( 
  bar REF BarType, 
  beer REF BeerType, 
  price FLOAT
);

// A REF(T) SCOPE R: A reference to tuples in relation R, where R is a table whose type is UDT T
CREATE TYPE MenuType AS (
	bar REF(BarType) scope Bars, 
  beer REF(BeerType) scope Beers, 
  price FLOAT
);
```

**UDT’s as Rowtypes**

A table may be defined to have a schema that is a rowtype, rather than by listing its elements.

上面的例子是在表的属性中定义为某个自定义类型，下面是直接为这个表定义成该类型

Example:

```sql
CREATE TABLE <table name> OF <type name>
(<list of elements>);

CREATE TABLE Bars OF BarType (
  PRIMARY KEY (name)
);

CREATE TABLE Beers OF BeerType (
 	PRIMARY KEY (name)
);

CREATE TABLE Sells OF MenuType (
  PRIMARY KEY (bar, beer), 
  FOREIGN KEY ( . . . )
);
```

注意：如果按照以上定义形成的像Bars的关系，其每个元组并不包含BarType定义的两个属性，而是只包含该类型的对象

每个用户定义类型都有自己的同名类型构造器(Type Constructor)



#### Chapter10-3-2 - Operations on Object-Relational Data

**Creating Objects ID’s for Tables** 

- SYSTEM GENERATED: DBMS is responsible for maintaining a unique value in the column.
- DERIVED: use primary key of the relation to produce unique values for the column.

For example:

```sql
REF IS <attribute name> <how generated>

// 使用DBMS生成对象ID
CREATE TABLE Bars OF BarType (
	REF IS nameID SYSTEM GENERATED, 
  primary key (name)
);
```

**Accessing Values**

In SQL-99, each attribute of a UDT has **generator** (get the value) and **mutator** (change the value) methods of the same name as the attribute.

- The **generator** for A takes no argument, as A().
- The **mutator** for A takes a new value as argument, as A(v).

Example:

```sql
// table definition
CREATE TABLE Bars OF BarType { PRIMARY KEY (name)};

// query using generator
SELECT bb.name(), bb.addr() FROM Bars bb;
```

**Inserting Values**

1. Create a variable X of the suitable type, using the constructor method for that type.
2. Use the mutator methods for the attributes to set the values of the fields of X.
3. Insert X into the relation.

Example:

```sql
// 首先利用类生成器定义变量
SET newBar = BarType();

// 再利用修改器更新变量的成员
newBar.name('Joe"s Bar');
newBar.addr('Maple St.');

// 插入
INSERT INTO Bars VALUES(newBar);
```



**UDT’s as Column Types**

前面的例子是表为某个类型，当然也可以表中的某个属性为某个类型，此时表里存储的是一个指针，使用箭头->对成员进行访问

Example:

```sql
// Find the beers served by Joe
// 注：Sells表为UDT，使用上面的生成器对成员进行访问
// 后两个表的属性为UDT，使用指针进行访问
SELECT ss.beer()->name
	FROM Sells ss
	WHERE ss.bar()->name = 'Joe"s Bar';
```

**Using DEREF**

DEREF Applies to a reference and **produces the tuple referenced**.

Example:

```sql
// Table Definition
CREATE TABLE Sells (
	bar REF BarType,
	beer REF BeerType, 
  price FLOAT 
);

// To see the BeerType objects, use: 
SELECT DEREF(beer)
	FROM Sells
	WHERE bar→name = ’Joe’’s Bar’;
	
// Produces values like:
BeerType(’Bud’, ’Anheuser-Busch’)
```

**Order Methods**

- Each UDT T may define two methods called EQUAL and LESSTHAN.
  - Each takes an argument of type T and is applied to another object of type T.
  - Returns TRUE if and only if the target object is = (resp. <) the argument object.
- Allows objects of type T to be compared by =, <, >=, etc. in WHERE clauses and for sorting (ORDER BY).
- 即：可以自定义比较运算符从而在WHERE子句或者ORDER BY中发挥作用

Example:

```sql
// Two members of UDT T are considered equal if all of their corresponding components are equal.
CREATE ORDERING FOR T EQUALS ONLY BY STATE; 

// apply the function F to these objects to do 6 comparisons (< <= > >= = <>), so that F(x1,x2) <0, means x1<x2, // F(x1,x2)=0 means x1=x2, so on
CREATE ORDERING FOR T ORDERING FULL BY RELATIVE WITH F

// 上面一种情况的具体例子
CREATE ORDERING FOR AddressType
	ORDERING FULL BY RELATIVE WITH AddrLEG(example)
	
CREATE FUNCTION AddrLEG(x1 AddressType, x2 AddressType) RETURNS INTEGER
	IF x1.city() < x2.city() 
		THEN RETURN(-1)
	ELSEIF x1.city() > x2.city() 
		THEN RETURN(1) 
  ELSEIF x1.street() < x2.street() 
  	THEN RETURN(-1) 
 	ELSEIF x1.street() = x2.street() 
 		THEN RETURN(0) 
 	ELSE RETURN(1)
END IF;
```



### Chapter10-4 - Online Analysis

**OLTP (On-Line Transaction Processing)**

Most database operations involve OLTP: short, simple, frequent queries and/or modifications.

**OLAP (On-Line Application Processing)**

Few, but complex queries --- may run for hours. Queries do not depend on having an absolutely up-to- date database.

**The Data Warehouse**

The most common form of data integration.

1. Copy sources into a single DB (warehouse) and try to keep it up-to-date.
2. Usual method: periodic reconstruction of the warehouse, perhaps overnight.
3. Complex Queries (touch large portion of data for analytic queries.)
4. Infrequent updates.

**Star Schemas**

A star schema is a common organization for data at a **warehouse**. It consists of:

1. Fact table : a very large accumulation of facts such as sales. Often “insert-only.”

   - Two classes of fact-table attributes: 

     1. **Dimension** attributes : the key of a dimension table, such as bar.

     2. **Dependent** attributes : a value determined by the dimension attributes of the tuple, such as price.

2. Dimension tables : smaller, generally static information about the entities involved in the facts.

Example:

- The **fact table** is a relation: **Sales(bar, beer, drinker, day, time, price)**
  - Record information about every beer sale: the bar, the brand of beer, the drinker who bought the beer, the day, the time, and the price charged.
- The **dimension tables** include information about the bar, beer, and drinker “dimensions”:
  - Bars(bar, addr, license) 
  - Beers(beer, manf) 
  - Drinkers(drinker, addr, phone)

**Approaches to Building Warehouses**

1. **ROLAP** = “relational OLAP”: Tune a relational DBMS to support star schemas.

   1. **Bitmap indexes** : For each key value of a dimension table (e.g., each beer for relation Beers) create a bit-vector telling which tuple of the fact table have that value. （对于dimension table的每个键值创建一个位向量以确定fact table的哪个元组有这个值）

      - 键值有几种可能的取值，Bitmap Index就有几列，每列的属性即为各个取值；行数与原表行数相同，0代表该行不取该值，1代表取该值
      - 这种特性使得系统使用AND运算就可以进行快速查询
      - The typical OLAP query will: 
        1. Start with a star join.
        2. Select for interesting tuples, based on dimension data.
        3. Group by one or more dimensions. 
        4. Aggregate certain attributes of the result.

   2. **Materialized views** : Store the views to several useful queries in the warehouse itself.

      - Running this query: from Sales and the dimension tables could take too long.

      - Saving materialized view: that contains enough information, answer query would be much faster.

      - Example:

        - Key issues:

          1. It must join Sales, Bars, and Beers, at least.
          2. It must group by at least bar and beer.
          3. It must not select out Palo-Alto bars or Anheuser- Busch beers.
          4. It must not project out addr or manf.

        - ```sql
          CREATE VIEW BABMS(bar, addr, beer, manf, sales) AS
            (SELECT bar, addr, beer, manf, SUM(price) as sales 
               FROM Sales NATURAL JOIN Bars NATURAL JOIN Beers
               GROUP BY bar, addr, beer, manf);
          ```

          

2. **MOLAP** = “multidimensional OLAP”: Use a specialized DBMS with a model such as the “data cube.”
   - Keys of dimension tables are the dimensions of a hypercube.
   - Dependent attributes (e.g., price) appear at the points of the cube.
   - 即一个高维矩阵，每一个维度都多了一个元素\*代表该元素的总和（像Python的:）?
   - **Drill-Down**
     - Drill-down = “de-aggregate” = break an aggregate into its constituents.
     - Example: having determined that Joe’s Bar sells very few Anheuser-Busch beers, break down his sales by particular A.-B. beer.
     - 即反聚合，分解被聚合的元素
   - **Roll-Up**
     - Roll-up = aggregate along one or more dimensions.
     - Example: given a table of how much Bud each drinker consumes at each bar, roll it up into a table giving total amount of Bud consumed by each drinker.
     - 即聚合
   - **Slicing**
     - Slicing = focusing on particular one dimension with fixed value.
     - 即选择
   - **Dicing**
     - Dicing = focusing on particular partitions along one or more dimensions.
     - 即投影+选择

**The cube operator in SQL - with cube**

The **cube** operation computes union of **group by**’s on every subset of the specified attributes

Example:

```sql
Select dimension-attributes, aggregations From tables
Where conditions
Group by dimension-attributes with cube

select drinker, bar, beer, sum(price) from sales
group by drinker, bar, beer with cube
// This computes the union of eight different groupings of the sales relation:
// { (drinker, bar, beer), (drinker, bar), (drinker, beer), (bar, beer), (drinker), (bar), (beer), ( ) }

// For each grouping, the result contains the null value for attributes not present in the grouping.
```

**with rollup**

Example:

```sql
Select dimension-attributes,aggregations From tables
Where conditions
Group by dimension-attributes with rollup

select drinker, bar, beer, sum(price) from sales
group by drinker, bar, beer with Rollup
// Generates union of four groupings:
// { (drinker, bar, beer), (drinker, bar), (drinker), ( ) }

// Rollup can be used to generate aggregates at multiple levels of a hierarchy.
```



























